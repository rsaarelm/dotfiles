#!/usr/bin/env rust-script

//! Cut out loud noisy bits from podcast episodes.
//!
//! ```cargo
//! [dependencies]
//! anyhow = "1"
//! hound = "3"
//! rodio = "0.19"
//! ```

// Run in NixOS with nix-shell -p pkg-config alsaLib.dev

// Couldn't get mp3 encoding from Rust to work without crashing for big files.
// Currently outputs wav, to encode ogg, do
// cut-noise podcast.mp3 - | oggenc - -o quiet-podcast.ogg
// (oggenc is in NixOS package vorbis-tools)

use std::{env, fs::File, io::BufReader};

use rodio::Source;

// Different thresholds so there's some hysteresis once we start clipping.
// XXX: The same threshold probably won't work with all clips.
const START_CLIP_THRESHOLD: f64 = 2.1;
const STOP_CLIP_THRESHOLD: f64 = START_CLIP_THRESHOLD - 0.02;

// Smallest duration to clip.
const MIN_CLIP_SECONDS: f64 = 1.0;

/// Map index over all integers into a mirror-tiled repetition of the array.
///
/// This can be used to look at the neighborhood of a wave array near the
/// beginning and the end of the actual data and to see similar content in
/// both directions.
fn smp<T: Copy>(a: &[T], i: isize) -> T {
    assert!(a.len() > 0);
    // Map into a single pair of the array and its mirror.
    let mut i = i.rem_euclid(a.len() as isize * 2) as usize;

    // If it's in the mirror half, flip it back to the main array.
    if i >= a.len() {
        i = a.len() * 2 - 1 - i;
    }

    a[i]
}

/// Low-pass filter on signal. Convert values to an average value over the
/// given sample window.
fn lowpass(a: &[f32], window: usize) -> impl Iterator<Item=f32> + '_ {
    assert!(window > 0);
    // Indices at the start and end of the window.
    let p1 = -(window as isize) / 2 - 1;
    let p2 = p1 + (window as isize);
    let mut sum = (p1..p2).map(|i| smp(a, i) * smp(a, i)).sum::<f32>();

    (0..a.len()).map(move |x| {
        let x = x as isize;
        // Remove last frame's contribution and add this frame's one.
        let p1 = x - (window as isize) / 2 - 1;
        sum -= smp(a, p1) * smp(a, p1);

        let p2 = p1 + (window as isize) + 1;
        sum += smp(a, p2) * smp(a, p2);

        sum / (window as f32)
    })
}

fn main() -> anyhow::Result<()> {
    let args: Vec<String> = env::args().collect();
    if args.len() != 3 {
        eprintln!("Usage: {} [input.mp3] [output.mp3]", args[0]);
        std::process::exit(1);
    }

    eprintln!("Loading MP3...");
    let decoder = rodio::Decoder::new(BufReader::new(File::open(&args[1])?))?;
    let rate = decoder.sample_rate() * 2; // Assume it's stereo so we double the rate.
    let wave: Vec<f32> = decoder.convert_samples().collect();

    eprintln!("Computing smoothed volume");
    let smoothing_factor: f64 = 1.0 / (rate as f64);

    let samp = rate as usize / 100;
    let avg_volume = wave
        .iter()
        .step_by(samp)
        .map(|&a| a as f64 * a as f64)
        .sum::<f64>()
        / (wave.len() / samp) as f64;
    eprintln!("Avg volume: {avg_volume}");

    eprintln!("Finding loud regions");
    let mut clips = Vec::new();
    let mut clip_start = None;
    let mut rolling_vol = 0.0;
    for (i, &s) in wave.iter().enumerate() {
        let s = (s as f64 * s as f64) / avg_volume;
        rolling_vol = s * smoothing_factor + rolling_vol * (1.0 - smoothing_factor);

        let pos = i & !1; // Position that's always even, works nice for stereo.
        match clip_start {
            None if rolling_vol > START_CLIP_THRESHOLD => {
                clip_start = Some(pos);
            }
            Some(a) if rolling_vol < STOP_CLIP_THRESHOLD => {
                let delta = (i - a) as f64 / rate as f64;
                if delta > MIN_CLIP_SECONDS {
                    clips.push((a, pos));
                }
                clip_start = None;
            }
            _ => {}
        }
    }

    eprintln!("Found {} clip regions", clips.len());

    for &(i, j) in &clips {
        let tstr = |i| {
            let t = (i as f64 / rate as f64).round() as i32;
            let s = t % 60;
            let m = (t / 60) % 60;
            let h = t / 3600;
            format!("{h}:{m:02}:{s:02}")
        };

        eprintln!("{} - {}", tstr(i), tstr(j));
    }

    eprintln!("Writing clipped wav...");

    let spec = hound::WavSpec {
        channels: 2,
        sample_rate: rate / 2,
        bits_per_sample: 32,
        sample_format: hound::SampleFormat::Float,
    };

    let output = if args[2] == "-" {
        "/dev/stdout"
    } else {
        &args[2]
    };

    let mut writer = hound::WavWriter::create(output, spec).unwrap();

    let mut i = 0;
    while i < wave.len() {
        writer.write_sample(wave[i])?;

        // Skip ahead when he hit a clip
        for &(a, b) in &clips {
            if i == a {
                i = b;
                continue;
            }
        }
        i += 1;
    }
    writer.finalize()?;

    Ok(())
}
