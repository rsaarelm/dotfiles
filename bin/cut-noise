#!/usr/bin/env rust-script

//! Cut out loud noisy bits from podcast episodes.
//!
//! ```cargo
//! [dependencies]
//! anyhow = "1"
//! hound = "3"
//! rodio = "0.19"
//! ```

// Run in NixOS with nix-shell -p pkg-config alsaLib.dev vorbis-tools

// Couldn't get mp3 encoding from Rust to work without crashing for big files.
// Currently outputs wav, to encode ogg, do
// cut-noise podcast.mp3 - | oggenc - -o quiet-podcast.ogg

use std::{env, fs::File, io::BufReader};

use rodio::Source;

// Different thresholds so there's some hysteresis once we start clipping.
// XXX: The same threshold probably won't work with all clips.
const START_CLIP_THRESHOLD: f64 = 2.1;
const STOP_CLIP_THRESHOLD: f64 = START_CLIP_THRESHOLD - 0.02;

// Smallest duration to clip.
const MIN_CLIP_SECONDS: f64 = 1.0;

fn main() -> anyhow::Result<()> {
    let args: Vec<String> = env::args().collect();
    if args.len() != 3 {
        eprintln!("Usage: {} [input.mp3] [output.mp3]", args[0]);
        std::process::exit(1);
    }

    eprintln!("Loading MP3...");
    let decoder = rodio::Decoder::new(BufReader::new(File::open(&args[1])?))?;
    let rate = decoder.sample_rate() * 2; // Assume it's stereo so we double the rate.
    let wave: Vec<f32> = decoder.convert_samples().collect();

    eprintln!("Computing smoothed volume");
    let smoothing_factor: f64 = 1.0 / (rate as f64);

    let samp = rate as usize / 100;
    let avg_volume = wave
        .iter()
        .step_by(samp)
        .map(|&a| a as f64 * a as f64)
        .sum::<f64>()
        / (wave.len() / samp) as f64;
    eprintln!("Avg volume: {avg_volume}");

    eprintln!("Finding loud regions");
    let mut clips = Vec::new();
    let mut clip_start = None;
    let mut rolling_vol = 0.0;
    for (i, &s) in wave.iter().enumerate() {
        let s = (s as f64 * s as f64) / avg_volume;
        rolling_vol = s * smoothing_factor + rolling_vol * (1.0 - smoothing_factor);

        let pos = i & !1; // Position that's always even, works nice for stereo.
        match clip_start {
            None if rolling_vol > START_CLIP_THRESHOLD => {
                clip_start = Some(pos);
            }
            Some(a) if rolling_vol < STOP_CLIP_THRESHOLD => {
                let delta = (i - a) as f64 / rate as f64;
                if delta > MIN_CLIP_SECONDS {
                    clips.push((a, pos));
                }
                clip_start = None;
            }
            _ => {}
        }
    }

    eprintln!("Found {} clip regions", clips.len());

    for &(i, j) in &clips {
        let tstr = |i| {
            let t = (i as f64 / rate as f64).round() as i32;
            let s = t % 60;
            let m = (t / 60) % 60;
            let h = t / 3600;
            format!("{h}:{m:02}:{s:02}")
        };

        eprintln!("{} - {}", tstr(i), tstr(j));
    }

    eprintln!("Writing clipped wav...");

    let spec = hound::WavSpec {
        channels: 2,
        sample_rate: rate / 2,
        bits_per_sample: 32,
        sample_format: hound::SampleFormat::Float,
    };

    let output = if args[2] == "-" {
        "/dev/stdout"
    } else {
        &args[2]
    };

    let mut writer = hound::WavWriter::create(output, spec).unwrap();

    let mut i = 0;
    while i < wave.len() {
        writer.write_sample(wave[i])?;

        // Skip ahead when he hit a clip
        for &(a, b) in &clips {
            if i == a {
                i = b;
                continue;
            }
        }
        i += 1;
    }
    writer.finalize()?;

    Ok(())
}
