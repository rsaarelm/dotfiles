#!/usr/bin/env rust-script

//! Extract a TODO list in todo.txt format from a git project
//!
//! ```cargo
//! [dependencies]
//! anyhow = "1"
//! chrono = "0.4"
//! clap = { version = "4", features = ["derive"] }
//! lazy-regex = "3"
//! memoize = "0.4"
//! regex = "1"
//! ```

// TODO: Use cargo script runner when it's stable instead of rust-script,
// https://github.com/rust-lang/cargo/issues/12207

use anyhow::{Result, bail};
use clap::Parser;
use lazy_regex::regex;
use memoize::memoize;
use regex::Regex;
use std::{
    collections::HashMap,
    fs::read_to_string,
    process::{Command, Stdio},
    rc::Rc,
};

#[derive(Parser, Debug)]
struct Args {
    /// Keyword to search for, default TODO
    #[arg(long, default_value = "TODO")]
    keyword: String,

    /// Search outline TODOs instead of comment TODOs, outline TODO is [_]
    /// with only whitespace before it.
    #[arg(long)]
    outline_todos: bool,

    /// Whether date values should be left out.
    #[arg(long)]
    omit_dates: bool,
}

fn main() -> Result<()> {
    let args = Args::parse();

    // Valid TODO items are a single comment marker followed immediately by
    // "TODO", optionally followed with a colon that is dropped. The subsequent
    // text, and the text of any lines below that have the exact same comment
    // prefix and do not start with "TODO" are added to the item sans the prefix.
    let todo_re = Regex::new(&format!(r"^(\s*\S{{1,4}}\s+){}:? (.*)$", args.keyword)).unwrap();
    let priority_re = regex!(r"^(\(.\)) (.*)$");

    let outline_re = regex!(r"\s*\[_\] (.*)$");

    let mut todo_list = Vec::new();

    for path in list_files()? {
        let Ok(text) = read_to_string(&path) else {
            // eprintln!("Failed to read {path} into UTF-8 string, skipping.");
            continue;
        };

        if is_binary(&text) {
            // eprintln!("File {path} is probably binary, skipping.");
            continue;
        }

        let mut lines = text.lines().enumerate().peekable();

        while let Some((n, line)) = lines.next() {
            let n = n + 1;
            if !args.outline_todos {
                if let Some(caps) = todo_re.captures(line) {
                    // Matched a TODO item, grab the first line and see if it
                    // continues to the next.
                    let prefix = &caps[1];
                    let mut text = caps[2].trim().to_string();
                    while let Some((_, next_line)) = lines.peek() {
                        if let Some(next_line) = next_line.strip_prefix(prefix) {
                            let next_line = next_line.trim();
                            if !next_line.starts_with(&args.keyword) && !next_line.is_empty() {
                                text.push_str(" ");
                                text.push_str(next_line);
                                lines.next();
                                continue;
                            }
                        }
                        break;
                    }

                    let date = if args.omit_dates {
                        "".to_owned()
                    } else {
                        format!("{} ", blame_date(&path, n))
                    };

                    // Move priority marker in front of date.
                    if let Some(caps) = priority_re.captures(&text) {
                        todo_list.push(format!("{} {date}{}  ({path})", &caps[1], &caps[2]));
                    } else {
                        todo_list.push(format!("{date}{text}  ({path})"));
                    }
                }
            } else {
                if let Some(caps) = outline_re.captures(line) {
                    // Outline todos are simpler, they're always on one line.
                    let text = caps[1].trim();
                    let date = if args.omit_dates {
                        "".to_owned()
                    } else {
                        format!("{} ", blame_date(&path, n))
                    };

                    todo_list.push(format!("{date}{text}  ({path})"));
                }
            }
        }
    }

    todo_list.sort();
    for line in todo_list {
        println!("{line}");
    }

    Ok(())
}

fn list_files() -> Result<Vec<String>> {
    let output = Command::new("git")
        .arg("ls-files")
        .stdout(Stdio::piped())
        .output()?;

    if output.status.success() {
        let stdout = String::from_utf8(output.stdout)?;
        let files: Vec<String> = stdout.lines().map(String::from).collect();
        Ok(files)
    } else {
        let stderr = String::from_utf8(output.stderr)?;
        if stderr.contains("not a git repository") {
            bail!("current directory is not in a git repository")
        } else {
            bail!("git ls-files command failed")
        }
    }
}

fn blame_date(path: &str, line: usize) -> Rc<String> {
    blame_dates(path.to_string())[line - 1].clone()
}

#[memoize]
fn blame_dates(path: String) -> Rc<Vec<Rc<String>>> {
    // SHA-1 hash for each line.
    let sha_line = regex!(r"^([0-9a-f]{40}) (\d+) (\d+)");

    let output = Command::new("git")
        .args(&["blame", "--porcelain", &path])
        .stdout(Stdio::piped())
        .output()
        .unwrap();

    if !output.status.success() {
        panic!("git blame failed")
    }

    let stdout = String::from_utf8(output.stdout).expect("invalid UTF-8 in git blame output");

    let mut result = Vec::new();

    let mut last_sha: &str = "";
    let mut timestamp: i64 = 0;
    let mut sha_to_date = HashMap::new();

    // We need to parse the machine-friendly git blame output to get the date
    // for each line.
    for line in stdout.lines() {
        // Each line is identified with a SHA-1 hash, recognize that to see
        // which commit we're on.
        if let Some(caps) = sha_line.captures(line) {
            last_sha = caps.get(1).unwrap().as_str();
        }
        // Date is declared with a line that stast with `author-time` and it
        // has a unix timestamp as value. It maps to the last SHA-1 seen.
        else if line.starts_with("author-time ") {
            let timestamp_str = line["author-time ".len()..].trim();
            timestamp = timestamp_str
                .parse()
                .expect("invalid author_time in git blame output");
        }
        // Once we get the timezone, we can construct the date.
        // It's assumed here that we saw the author-time line before this.
        else if line.starts_with("author-tz ") {
            let tz_str = line["author-tz ".len()..].trim();
            let tz: i64 = tz_str
                .parse()
                .expect("invalid author_tz in git blame output");
            // Stupid trick to convert +0200 style timezone to seconds.
            let delta = tz / 100 * 3600;
            let dt = chrono::DateTime::from_timestamp(timestamp + delta, 0)
                .expect("invalid timestamp in git blame output");
            sha_to_date.insert(last_sha, Rc::new(dt.format("%Y-%m-%d").to_string()));
        }
        // If we get a line starting with tab, then it's an actual line of
        // code, emit the date.
        else if line.starts_with('\t') {
            result.push(sha_to_date[last_sha].clone());
        }
    }

    Rc::new(result)
}

fn is_binary(text: &str) -> bool {
    // Replicating functionality of binaryornot crate that's currently
    // prone to random panics because of a stale dependency.
    // (https://github.com/keirlawson/binaryornot/issues/1)

    fn is_unprintable(value: char) -> bool {
        if value as u32 > 128 {
            return false;
        }

        match value as u8 {
            b'\n' | b'\r' | b'\t' | b'\x0C' | b'\x08' => false,
            0..32 | 127 => true,
            _ => false,
        }
    }

    fn is_high_ascii(value: char) -> bool {
        matches!(value as u32, 128..256)
    }

    let mut n = 0;
    let mut high = 0;
    let mut unprintable = 0;
    for c in text.chars().take(1000) {
        n += 1;
        if is_unprintable(c) {
            unprintable += 1;
        }
        if is_high_ascii(c) {
            high += 1;
        }
    }

    if n == 0 {
        // Empty file, count as text.
        return false;
    }

    let high = high as f32 / n as f32;
    let unprintable = unprintable as f32 / n as f32;

    unprintable > 0.05 || high > 0.3
}
