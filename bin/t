#!/usr/bin/env python3
# Time logger
# Inspired by http://messymatters.com/tagtime/

from datetime import datetime, timezone
import collections
import math
import os
import os.path
import time
import random
import sys

AVG_MINUTES = 45

LOG_FILE = os.getenv('T_LOG_FILE', '%s/my-activity.log' % os.getenv('HOME', './'))

DATE_FMT = "%Y-%m-%dT%H:%M:%S%z"

def parse_date(date_str):
	return int(datetime.strptime(date_str.strip(), DATE_FMT).timestamp())

def emit_date(unix_time):
	tz = datetime.now(timezone.utc).astimezone().tzinfo # XXX: Any better way to do this pre-Python 3.6?
	return datetime.fromtimestamp(unix_time, tz).astimezone().strftime(DATE_FMT)

def unix_day(unix_time):
	return int(unix_time / 86400)

NOISE_MAX = 0x7fffffff
def noise(x):
	x = (x >> 13) ^ x;
	return (x * (x * x * 60493 + 19990303) + 1376312589) & NOISE_MAX

def day_schedule(day):
	day = range(day * 86400, day * 86400 + 86400)
	return [t for t in day if noise(t) < NOISE_MAX / (AVG_MINUTES * 60)]

def next_ping_time(unix_time):
	unix_time = int(unix_time)
	day = unix_day(unix_time)
	sched = day_schedule(day)
	sched.extend(day_schedule(day + 1))

	while sched[0] <= unix_time:
		sched = sched[1:]

	return sched[0]

def prev_ping_time(unix_time):
	unix_time = int(unix_time)
	day = unix_day(unix_time)
	sched = day_schedule(day - 1)
	sched.extend(day_schedule(day))

	while sched[-1] > unix_time:
		sched = sched[:-1]

	return sched[-1]

def last_entry(logfile):
	try:
		with open(logfile) as f:
			lines = f.readlines()
			if len(lines) == 0:
				return (None, None)
			items = lines[-1].split(' ')
			assert(len(items) > 0 and len(items) <= 2)
			if len(items) == 2:
				tag = items[1]
			else:
				tag = None
			date = parse_date(items[0])
			return (date, tag)
	except FileNotFoundError:
		return (None, None)

def add_entry(time, tag, logfile):
	with open(logfile, 'a+') as f:
		date = emit_date(time)
		if tag:
			assert(' ' not in tag)
			print("%s %s" % (date, tag), file=f)
		else:
			print("%s" % (date,), file=f)

def catch_up(time_now, logfile, max_seconds=24*60*60, fill_tag=None):
	"""Fill missed entries to logfile."""
	date, tag = last_entry(logfile)
	filled = 0
	if not date:
		return filled
	if time_now - date >= max_seconds:
		return filled
	date = next_ping_time(date)
	prev = prev_ping_time(time_now)
	while date < prev:
		add_entry(date, fill_tag, logfile)
		date = next_ping_time(date)
		filled += 1
	return filled

def missed_entries(time_now, logfile, max_seconds=24*60*60):
	"""Count number of missing entries between last entry and current one"""
	# XXX: Repeats a lot of logic with catch_up
	date, tag = last_entry(logfile)
	if not date:
		return 0
	if time_now - date >= max_seconds:
		return 0
	date = next_ping_time(date)
	prev = prev_ping_time(time_now)
	ret = 0
	while date < prev:
		date = next_ping_time(date)
		ret += 1
	return ret

def input_or_die(prompt, timeout=60):
	t = threading.Timer(timeout, sys.exit, "timed out")
	t.start()
	ret = input(prompt)
	t.cancel()
	return ret

def run():
	next = next_ping_time(time.time())
	while True:
		t = time.time()
		if t > next:
			msg("log status for %s" % emit_date(next))
			next = next_ping_time(t)
		else:
			# Don't sleep more than a minute at a time so as to recover
			# better from daemon machine suspend
			time.sleep(max(next - t + 1, 60))

def on_windows():
	return os.name == 'nt'

def msg(text, show_secs=2):
	if on_windows():
		os.system('%%SystemRoot%%/Sysnative/msg /time:%s "%%username%%" %s' % (show_secs, text))
	else:
		os.system('xmessage -timeout %s %s' % (show_secs, text))

def save_tag(tag, logfile):
	t = time.time()
	fill_missed = None
	# Hidden feature, use capitalized TAG to fill up all the missed features
	# Eg. do `t SLEEP` when waking up.
	if tag.isupper():
		tag = tag.lower()
		fill_missed = tag
	date, oldtag = last_entry(logfile)
	prev = prev_ping_time(t)
	if date and date >= prev:
		print("Log already covers time up to %s, please edit manually" % emit_date(prev))
		return
	fill = catch_up(t, logfile, fill_tag=fill_missed)
	if fill:
		print("Caught up with %s missing entries" % fill)
		if fill_missed:
			print("Filed all missing entires as %s" % tag)
	add_entry(prev, tag, logfile)
	print("Filed %s %s" % (emit_date(prev), tag))

def show_status(logfile):
	t = time.time()
	date, oldtag = last_entry(logfile)
	prev = prev_ping_time(t)
	prev_str = emit_date(prev)
	if date and date >= prev:
		if oldtag:
			print("Last sample %s already logged as %s" % (prev_str, oldtag))
		else:
			print("Last sample %s logged, but has no tag, please edit the log" % prev_str)
		return
	print("Last sample %s is unlogged, please enter tag" % prev_str)
	missed = missed_entries(t, logfile)
	if missed > 0:
		print("Also missing %d entries before that, enter tag CAPITALIZED to fill all with it" % missed)
	print("Press Ctrl-C to abort")
	try:
		tag = input("> ").strip()
	except KeyboardInterrupt:
		print("")
		return
	if tag == None or ' ' in tag:
		print("Invalid tag, aborting")
		return
	if tag == '':
		print("Logging empty timestamp")
	save_tag(tag, logfile)

def parse_log(logfile):
	ret = []
	with open(logfile) as f:
		for line in f.readlines():
			line = line.split('#')[0].strip() # Remove comments
			if not line:
				continue
			items = line.split(' ')
			assert(len(items) > 0 and len(items) <= 2)
			if len(items) == 2:
				tag = items[1]
			else:
				tag = None
			# Get rich time data, we may want time zone knowledge
			timedata = datetime.strptime(items[0].strip(), DATE_FMT)
			ret.append((timedata, tag))
	return ret

def summarize(days):
	freqs = collections.Counter([tag for day in days for tag in days[day]])
	hours_c = AVG_MINUTES / len(days) / 60
	for (tag, count) in freqs.items():
		# The magic analysis formula, just assume that each tag averages out to
		# the sampling interval when the tag count increases.
		#
		# (This does assume that all the data has been generated using the same
		# average formula...)
		print("%s: %.1f h" % (tag, (count * hours_c)))

def analyze(data):
	dates = [x[0] for x in data]
	days = collections.defaultdict(list)
	for (date, tag) in data:
		if tag:
			days[(date.year, date.month, date.day)].append(tag)
	workdays = dict([(day, tags) for day, tags in days.items() if "work" in tags])
	print("Workday stats: ")
	summarize(workdays)
	print()
	print("Global stats: ")
	summarize(days)

if __name__ == '__main__':
	if len(sys.argv) == 1:
		show_status(LOG_FILE)
	elif sys.argv[1] == '--daemon':
		# Wait a little bit in case we're starting from .xinit
		time.sleep(2)
		msg("Starting time tracking daemon")
		run()
	elif sys.argv[1] == '--summary':
		# Summarize your day
		analyze(parse_log(LOG_FILE))
	elif len(sys.argv) == 2:
		save_tag(sys.argv[1], LOG_FILE)
	else:
		print("Usage %s (--daemon | [last_tag])" % sys.argv[0])
