#!/usr/bin/env python3
# Time logger
# Inspired by http://messymatters.com/tagtime/

from datetime import datetime, timezone
import math
import os
import os.path
import time
import random
import sys

AVG_MINUTES = 45

LOG_FILE = os.getenv('T_LOG_FILE', '%s/my-activity.log' % os.getenv('HOME', './'))

DATE_FMT = "%Y-%m-%dT%H:%M:%S%z"

def parse_date(date_str):
	return int(datetime.strptime(date_str.strip(), DATE_FMT).timestamp())

def emit_date(unix_time):
	tz = datetime.now(timezone.utc).astimezone().tzinfo # XXX: Any better way to do this pre-Python 3.6?
	return datetime.fromtimestamp(unix_time, tz).astimezone().strftime(DATE_FMT)

def unix_day(unix_time):
	return int(unix_time / (24*60*60))

# Must use the same random numbers everywhere this is run for different daemons
# to stay synched to the official schedule, so use a crappy fixed generator.
g_rng_seed = 0
RNG_MAX = 2**31 - 1

def seed_rng(seed):
	global g_rng_seed
	g_rng_seed = int(seed)

def portable_rng():
	global g_rng_seed
	g_rng_seed = (1103515245 * g_rng_seed + 12345) % RNG_MAX
	return g_rng_seed

def day_schedule(day):
	def random_wait():
		mean = AVG_MINUTES * 60
		r = float(portable_rng()) / RNG_MAX
		wait = int(-1 * mean * math.log(r))
		# Clamp out outlier values
		return max(mean // 4, min(mean * 4, wait))
	seed_rng(day)
	t = day * 24*60*60
	t += random_wait()
	ret = []
	while unix_day(t) == day:
		ret.append(t)
		t += random_wait()
	return ret

def next_ping_time(unix_time):
	unix_time = int(unix_time)
	day = unix_day(unix_time)
	sched = day_schedule(day)
	sched.extend(day_schedule(day + 1))

	while sched[0] <= unix_time:
		sched = sched[1:]

	return sched[0]

def prev_ping_time(unix_time):
	unix_time = int(unix_time)
	day = unix_day(unix_time)
	sched = day_schedule(day - 1)
	sched.extend(day_schedule(day))

	while sched[-1] > unix_time:
		sched = sched[:-1]

	return sched[-1]

def last_entry(logfile):
	try:
		with open(logfile) as f:
			lines = f.readlines()
			if len(lines) == 0:
				return (None, None)
			items = lines[-1].split(' ')
			assert(len(items) > 0 and len(items) <= 2)
			if len(items) == 2:
				tag = items[1]
			else:
				tag = None
			date = parse_date(items[0])
			return (date, tag)
	except FileNotFoundError:
		return (None, None)

def add_entry(time, tag, logfile):
	with open(logfile, 'a+') as f:
		date = emit_date(time)
		if tag:
			assert(' ' not in tag)
			print("%s %s" % (date, tag), file=f)
		else:
			print("%s" % (date,), file=f)

def catch_up(time_now, logfile, max_seconds=24*60*60, fill_tag=None):
	"""Fill missed entries to logfile."""
	date, tag = last_entry(logfile)
	filled = 0
	if not date:
		return filled
	if time_now - date >= max_seconds:
		return filled
	date = next_ping_time(date)
	prev = prev_ping_time(time_now)
	while date < prev:
		add_entry(date, fill_tag, logfile)
		date = next_ping_time(date)
		filled += 1
	return filled

def input_or_die(prompt, timeout=60):
	t = threading.Timer(timeout, sys.exit, "timed out")
	t.start()
	ret = input(prompt)
	t.cancel()
	return ret

def run():
	next = next_ping_time(time.time())
	while True:
		t = time.time()
		if t > next:
			msg("log status for %s" % emit_date(next))
			next = next_ping_time(t)
		else:
			# Don't sleep more than a minute at a time so as to recover
			# better from daemon machine suspend
			time.sleep(max(next - t + 1, 60))

def on_windows():
	return os.name == 'nt'

def msg(text, show_secs=2):
	if on_windows():
		os.system('%%SystemRoot%%/Sysnative/msg /time:%s "%%username%%" %s' % (show_secs, text))
	else:
		os.system('xmessage -timeout %s %s' % (show_secs, text))

def save_tag(tag, logfile):
	t = time.time()
	fill_missed = None
	# Hidden feature, use capitalized TAG to fill up all the missed features
	# Eg. do `t SLEEP` when waking up.
	if tag.isupper():
		tag = tag.lower()
		fill_missed = tag
	date, oldtag = last_entry(logfile)
	prev = prev_ping_time(t)
	if date and date >= prev:
		print("Log already covers time up to %s, please edit manually" % emit_date(prev))
		return
	fill = catch_up(t, logfile, fill_tag=fill_missed)
	if fill:
		print("Caught up with %s missing entries" % fill)
		if fill_missed:
			print("Filed all missing entires as %s" % tag)
	add_entry(prev, tag, logfile)
	print("Filed %s %s" % (emit_date(prev), tag))

def show_status(logfile):
	t = time.time()
	date, oldtag = last_entry(logfile)
	prev = prev_ping_time(t)
	prev_str = emit_date(prev)
	if date and date >= prev:
		if oldtag:
			print("Last sample %s already logged as %s" % (prev_str, oldtag))
		else:
			print("Last sample %s logged, but has no tag, please edit the log")
		return
	print("Last sample %s is unlogged, please enter tag" % prev_str)
	print("Press Ctrl-C to abort")
	try:
		tag = input("> ").strip()
	except KeyboardInterrupt:
		print("")
		return
	if tag == None or ' ' in tag:
		print("Invalid tag, aborting")
		return
	if tag == '':
		print("Logging empty timestamp")
	save_tag(tag, logfile)

if __name__ == '__main__':
	if len(sys.argv) == 1:
		show_status(LOG_FILE)
	elif sys.argv[1] == '--daemon':
		msg("Starting time tracking daemon")
		run()
	elif len(sys.argv) == 2:
		save_tag(sys.argv[1], LOG_FILE)
	else:
		print("Usage %s (--daemon | [last_tag])" % sys.argv[0])
