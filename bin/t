#!/usr/bin/env python3
# Time logger
# Inspired by http://messymatters.com/tagtime/

from datetime import datetime
import math
import os
import os.path
import time
import random
import sys

AVG_MINUTES = 45

LOG_FILE = os.getenv('T_LOG_FILE', '%s/my-activity.log' % os.getenv('HOME', './'))

DATE_FMT = "%Y-%m-%dT%H:%M:%S%z"

def parse_date(date_str):
	return int(datetime.strptime(date_str.strip(), DATE_FMT).timestamp())

def emit_date(unix_time):
	return datetime.fromtimestamp(unix_time).astimezone().strftime(DATE_FMT)

def unix_day(unix_time):
	return int(unix_time / (24*60*60))

def day_schedule(day):
	def random_wait():
		mean = AVG_MINUTES * 60
		wait = int(-1 * mean * math.log(random.random()))
		# Clamp out outlier values
		return max(mean // 4, min(mean * 4, wait))

	t = day * 24*60*60
	random.seed(t)
	t += random_wait()
	ret = []
	while unix_day(t) == day:
		ret.append(t)
		t += random_wait()
	return ret

def next_ping_time(unix_time):
	unix_time = int(unix_time)
	day = unix_day(unix_time)
	sched = day_schedule(day)
	sched.extend(day_schedule(day + 1))

	while sched[0] <= unix_time:
		sched = sched[1:]

	return sched[0]

def prev_ping_time(unix_time):
	unix_time = int(unix_time)
	day = unix_day(unix_time)
	sched = day_schedule(day - 1)
	sched.extend(day_schedule(day))

	while sched[-1] > unix_time:
		sched = sched[:-1]

	return sched[-1]

def last_entry(logfile):
	try:
		with open(logfile) as f:
			lines = f.readlines()
			if len(lines) == 0:
				return (None, None)
			items = lines[-1].split(' ')
			assert(len(items) > 0 and len(items) <= 2)
			if len(items) == 2:
				tag = items[1]
			else:
				tag = None
			date = parse_date(items[0])
			return (date, tag)
	except FileNotFoundError:
		return (None, None)

def add_entry(time, tag, logfile):
	with open(logfile, 'a+') as f:
		date = emit_date(time)
		if tag:
			assert(' ' not in tag)
			print("%s %s" % (date, tag), file=f)
		else:
			print("%s" % (date,), file=f)

def catch_up(time_now, logfile, max_seconds=24*60*60):
	"""Fill missed entries to logfile."""
	date, tag = last_entry(logfile)
	filled = 0
	if not date:
		return filled
	if time_now - date >= max_seconds:
		return filled
	date = next_ping_time(date)
	prev = prev_ping_time(time_now)
	while date < prev:
		add_entry(date, None, logfile)
		date = next_ping_time(date)
		filled += 1
	return filled

def input_or_die(prompt, timeout=60):
	t = threading.Timer(timeout, sys.exit, "timed out")
	t.start()
	ret = input(prompt)
	t.cancel()
	return ret

def run():
	while True:
		t = time.time()
		next = next_ping_time(t)
		print("Next ping at %s" % emit_date(next))
		sys.stdout.flush()
		time.sleep(next - t + 1)
		t = time.time()
		msg("log status")

def on_windows():
	return os.name == 'nt'

def msg(text, show_secs=2):
	if on_windows():
		os.system('%%SystemRoot%%/Sysnative/msg /time:%s "%%username%%" %s' % (show_secs, text))
	else:
		os.system('xmessage -timeout %s %s' % (show_secs, text))

def save_tag(tag, logfile):
	t = time.time()
	date, oldtag = last_entry(logfile)
	prev = prev_ping_time(t)
	if date and date >= prev:
		print("Log already covers time up to %s, please edit manually" % emit_date(prev))
		return
	fill = catch_up(t, logfile)
	if fill:
		print("Caught up with %s missing entries" % fill)
	add_entry(prev, tag, logfile)
	print("Filed %s %s" % (emit_date(prev), tag))

if __name__ == '__main__':
	if len(sys.argv) == 1:
		print("Starting daemon mode")
		run()
	elif len(sys.argv) == 2:
		save_tag(sys.argv[1], LOG_FILE)
	else:
		print("Usage %s [last_tag]" % sys.argv[0])
