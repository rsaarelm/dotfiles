#!/usr/bin/env rust-script

//! ```cargo
//! [dependencies]
//! anyhow = "1"
//! chrono = "0.4"
//! clap = { version = "4", features = ["derive"] }
//! dirs = "5"
//! regex = "1"
//! ```

// Edit this constant if you want a different average ping interval.
const AVERAGE_PING_INTERVAL: i64 = 45 * 60;

use anyhow::{Context, Result};
use chrono::{DateTime, FixedOffset, NaiveDate};
use clap::Parser;
use regex::Regex;
use std::{
    collections::HashSet,
    fmt,
    fs::{self, OpenOptions},
    io::Write,
    path::{Path, PathBuf},
    str::FromStr,
    sync::OnceLock,
};

#[derive(Parser, Debug)]
/// Tagged Time Tracker
///
/// Stochastic time tracking tool.
struct Args {
    #[arg(short = 'm', long)]
    /// Display a minimal status string.
    minimal: bool,

    #[arg(long)]
    /// Sleep until next ping.
    sleep: bool,

    #[arg(long)]
    /// Show missed pings for the last 24 hours.
    missed: bool,

    #[arg(long)]
    /// Optional log path.
    log_path: Option<PathBuf>,

    /// Task identifier.
    task: Option<String>,

    /// Additional task description.
    comment: Vec<String>,
}

impl Args {
    pub fn log_path(&self) -> PathBuf {
        if let Some(path) = &self.log_path {
            path.clone()
        } else {
            if let Some(data_dir) = dirs::data_dir() {
                data_dir.join("ttt/ttt.timedot")
            } else {
                "ttt.timedot".into()
            }
        }
    }
}

fn main() -> Result<()> {
    let args = Args::parse();

    let log = Log::load(args.log_path())?;
    log.print(&mut std::io::stdout().lock(), Default::default())
        .unwrap();

    Ok(())
}

struct Log {
    log: Vec<(NaiveDate, Entry)>,
    covered_pings: HashSet<i64>,
}

impl Log {
    pub fn load(path: impl AsRef<Path>) -> Result<Self> {
        let text = fs::read_to_string(path).with_context(|| "failed to load log file")?;

        let mut day = NaiveDate::default();
        let mut log = Vec::new();
        let mut covered_pings = HashSet::new();

        for line in text.lines() {
            if let Some(new_day) = parse_date(line) {
                day = new_day;
                continue;
            }

            if let Ok(entry) = line.parse::<Entry>() {
                let unix_time =
                    day.and_hms_opt(0, 0, 0).unwrap().and_utc().timestamp() + entry.time_offset;
                if is_ping(AVERAGE_PING_INTERVAL, unix_time) {
                    // If the logged task covers multiples of the ping
                    // duration, assume it's intended to cover multiple
                    // successive pings ending with the one it was filed on.
                    for p in backpings_from(unix_time)
                        .take((entry.duration_s / AVERAGE_PING_INTERVAL) as usize)
                    {
                        covered_pings.insert(p);
                    }
                }

                log.push((day, entry));
            }
        }

        Ok(Log { log, covered_pings })
    }

    pub fn append(&self, prev_date: NaiveDate, path: impl AsRef<Path>) -> Result<()> {
        let path = path.as_ref();
        // Ensure directory exists.
        if let Some(dir) = path.parent() {
            fs::create_dir_all(dir)?;
        }

        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(path)
            .with_context(|| "failed to open file for output")?;

        self.print(&mut file, prev_date)
    }

    fn print(&self, f: &mut impl Write, mut prev_date: NaiveDate) -> Result<()> {
        for (date, entry) in &self.log {
            if *date != prev_date {
                // Prev was default if this is the first defined date.
                // Don't write a preceding newline in that case.
                if prev_date != Default::default() {
                    writeln!(f)?;
                }
                writeln!(f, "{date}")?;
                prev_date = *date;
            }
            writeln!(f, "{entry}")?;
        }
        Ok(())
    }

    fn last_date(&self) -> NaiveDate {
        if self.log.is_empty() {
            Default::default()
        } else {
            self.log[self.log.len() - 1].0
        }
    }
}

/// Parse date lines into unix timestamps.
fn parse_date(line: &str) -> Option<NaiveDate> {
    let line = line.split(';').next().unwrap().trim(); // Strip comment
    for fmt in ["%Y-%m-%d", "%Y/%m/%d", "%Y.%m.%d"] {
        if let Ok(ret) = NaiveDate::parse_from_str(line, fmt) {
            return Some(ret);
        }
    }

    None
}

#[derive(Debug)]
struct Entry {
    id: String,
    duration_s: i64,
    time_of_day: String,
    time_offset: i64,
    comment: String,
}

impl FromStr for Entry {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        static CELL: OnceLock<Regex> = OnceLock::new();
        let re = CELL.get_or_init(|| {
            Regex::new(
            r"^\s*(\S+) \s+(\d+)(s|m|h|d|w|mo|y)?\s+; (\d\d:\d\d:\d\d(\+|-)\d\d\d\d)(\s+(.*))?$").unwrap()
        });

        let Some(caps) = re.captures(s) else {
            return Err(());
        };

        let id = caps[1].to_string();

        let mut duration_s = caps[2].parse().map_err(|_| ())?;
        match caps.get(3).map(|m| m.as_str()) {
            Some("s") => {}
            Some("m") => duration_s *= 60,
            None | Some("h") => duration_s *= 3600,
            Some("d") => duration_s *= 3600 * 24,
            Some("w") => duration_s *= 3600 * 24 * 7,
            Some("mo") => duration_s *= 3600 * 24 * 30,
            Some("y") => duration_s *= 3600 * 24 * 365,
            _ => return Err(()),
        }

        // The ".... ...." dots format of timedot isn't supported. Ttt will
        // never output times using it, so it should be okay to just skip
        // lines using it.

        let time_of_day = caps[4].to_string();

        // Check that the time of day is actually valid, parse it for unix
        // epoch zero day to get offset from the time of day.

        let timestamp = format!("1970-01-01T{time_of_day}");

        let time = DateTime::parse_from_str(&timestamp, "%Y-%m-%dT%H:%M:%S%z").map_err(|e| ())?;

        let time_offset = time.timestamp();

        let comment: String = if let Some(comment) = caps.get(7) {
            comment.as_str().into()
        } else {
            "".to_string()
        };

        Ok(Entry {
            id,
            duration_s,
            time_of_day,
            time_offset,
            comment,
        })
    }
}

impl fmt::Display for Entry {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(f, "{:24}  ", self.id)?;

        // Keep the time in smaller units if it doesn't split cleanly into minutes or hours.
        // YAGNI units larger than hour.
        let d = self.duration_s;
        let (unit, t) = if d < 60 || d % 60 != 0 {
            ("s", d as f32)
        } else if d < 3600 || d % 900 != 0 {
            ("m", (d as f32) / 60.0)
        } else {
            ("h", (d as f32) / 3600.0)
        };

        // XXX: Rust formatting doesn't let me do "omit .0 decimals but
        // also limit precision to n decimals", using a kludged up expression.
        let t_str = format!("{:.3}", t);
        let t_str = format!(
            "{}{}",
            t_str.trim_end_matches('0').trim_end_matches('.'),
            unit
        );

        write!(f, "{t_str:5}")?;

        write!(f, "  ; {}", self.time_of_day)?;

        if !self.comment.is_empty() {
            write!(f, " {}", self.comment)?;
        }

        Ok(())
    }
}

fn now() -> i64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs() as i64
}

fn backpings_from(t: i64) -> impl Iterator<Item = i64> {
    (0..)
        .map(move |x| t - x)
        .filter(|&t| is_ping(AVERAGE_PING_INTERVAL, t))
}

fn next_ping(mut t: i64) -> i64 {
    t += 1;
    while !is_ping(AVERAGE_PING_INTERVAL, t) {
        t += 1;
    }
    t
}

fn is_ping(avg_secs: i64, t: i64) -> bool {
    use std::num::Wrapping;

    let mut t = Wrapping(t);
    t ^= t << 13;
    t ^= t >> 7;
    t ^= t << 17;
    (t & Wrapping(0x7fffffffffffffff)).0 % avg_secs == 0
}
