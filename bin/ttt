#!/usr/bin/env rust-script

//! Tagged Time Tracker
//!
//! A stochastic time tracker.
//!
//! ```cargo
//! [dependencies]
//! anyhow = "1"
//! chrono = "0.4"
//! clap = { version = "4", features = ["derive"] }
//! regex = "1"
//! ```

const PING_SECONDS: i64 = 45 * 60;

use anyhow::{Context, Result};
use chrono::{DateTime, FixedOffset, NaiveDate};
use clap::Parser;
use regex::Regex;
use std::{fmt, fs::read_to_string, path::Path, str::FromStr, sync::OnceLock};

#[derive(Parser, Debug)]
struct Args {
    #[arg(short = 'm', long)]
    /// Display a minimal status string.
    minimal: bool,

    #[arg(long)]
    /// Sleep until next ping.
    sleep: bool,

    #[arg(long)]
    /// Show missed pings for the last 24 hours.
    missed: bool,

    /// Task identifier.
    task: Option<String>,

    /// Additional task description.
    comment: Vec<String>,
}

fn main() -> Result<()> {
    let args = Args::parse();

    let entry = format!(
        "{}  {}",
        args.task.unwrap_or("".to_string()),
        args.comment.join(" ")
    )
    .parse::<Entry>()
    .unwrap();

    println!("{entry:?}");
    println!("{entry}");

    let log = load_log("/home/rsaarelm/notes/ntt.timedot")?;
    for e in log {
        println!("{e}");
    }

    Ok(())
}

fn load_log(path: impl AsRef<Path>) -> Result<Vec<Entry>> {
    let log = read_to_string(path).with_context(|| "failed to load log file")?;

    let mut day = 0;
    let mut ret = Vec::new();

    for line in log.lines() {
        if let Some(newDay) = parse_date(line) {
            day = newDay;
            continue;
        }

        if let Ok(mut entry) = line.parse::<Entry>() {
            entry.unix_time += day;
            ret.push(entry);
        }
    }

    Ok(ret)
}

/// Parse date lines into unix timestamps.
fn parse_date(line: &str) -> Option<i64> {
    let line = line.split(';').next().unwrap().trim(); // Strip comment
    for fmt in ["%Y-%m-%d", "%Y/%m/%d", "%Y.%m.%d"] {
        if let Ok(ret) = NaiveDate::parse_from_str(line, fmt) {
            return Some(ret.and_hms_opt(0, 0, 0).unwrap().and_utc().timestamp());
        }
    }

    None
}

#[derive(Debug)]
struct Entry {
    id: String,
    duration_s: i64,
    time_of_day: String,
    unix_time: i64,
    comment: String,
}

impl FromStr for Entry {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        static CELL: OnceLock<Regex> = OnceLock::new();
        let re = CELL.get_or_init(|| {
            Regex::new(
            r"^\s*(\S+) \s+(\d+)(s|m|h|d|w|mo|y)?\s+; (\d\d:\d\d:\d\d(\+|-)\d\d\d\d)(\s+(.*))?$").unwrap()
        });

        let Some(caps) = re.captures(s) else {
            return Err(());
        };

        let id = caps[1].to_string();

        let mut duration_s = caps[2].parse().map_err(|_| ())?;
        match caps.get(3).map(|m| m.as_str()) {
            Some("s") => {}
            Some("m") => duration_s *= 60,
            None | Some("h") => duration_s *= 3600,
            Some("d") => duration_s *= 3600 * 24,
            Some("w") => duration_s *= 3600 * 24 * 7,
            Some("mo") => duration_s *= 3600 * 24 * 30,
            Some("y") => duration_s *= 3600 * 24 * 365,
            _ => return Err(()),
        }

        let time_of_day = caps[4].to_string();

        // Check that the time of day is actually valid, parse it for unix
        // epoch zero day to get offset from the time of day.

        let timestamp = format!("1970-01-01T{time_of_day}");

        let time = DateTime::parse_from_str(&timestamp, "%Y-%m-%dT%H:%M:%S%z").map_err(|e| ())?;

        let unix_time = time.timestamp();

        let comment: String = if let Some(comment) = caps.get(7) {
            comment.as_str().into()
        } else {
            "".to_string()
        };

        Ok(Entry {
            id,
            duration_s,
            time_of_day,
            unix_time,
            comment,
        })
    }
}

impl fmt::Display for Entry {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(f, "{}  ", self.id)?;

        // Keep the time in smaller units if it doesn't split cleanly into minutes or hours.
        // YAGNI units larger than hour.
        let d = self.duration_s;
        let (unit, t) = if d < 60 || d % 60 != 0 {
            ("s", d as f32)
        } else if d < 3600 || d % 900 != 0 {
            ("m", (d as f32) / 60.0)
        } else {
            ("h", (d as f32) / 3600.0)
        };

        // XXX: Rust formatting doesn't let me do "omit .0 decimals but
        // also limit precision to n decimals", using a kludged up expression.
        let t_str = format!("{:.3}", t);
        write!(
            f,
            "{}{}",
            t_str.trim_end_matches('0').trim_end_matches('.'),
            unit
        )?;

        write!(f, "  ; {}", self.time_of_day)?;

        if !self.comment.is_empty() {
            write!(f, " {}", self.comment)?;
        }

        Ok(())
    }
}

fn is_ping(avg_secs: i64, t: i64) -> bool {
    use std::num::Wrapping;

    let mut t = Wrapping(t);
    t ^= t << 13;
    t ^= t >> 7;
    t ^= t << 17;
    (t & Wrapping(0x7fffffffffffffff)).0 % avg_secs == 0
}
